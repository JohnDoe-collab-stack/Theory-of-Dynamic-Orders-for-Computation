"""
Sphere Monitors and Alerts
==========================

Real-time monitoring system for sphere constraints.

Features:
- Alert generation (warnings, critical, violations)
- Veto decisions
- Fuel tracking and predictions
- Audit logging

"""

from __future__ import annotations
from dataclasses import dataclass, field
from typing import List, Optional, Callable, TYPE_CHECKING
from enum import Enum, auto
from datetime import datetime
import json

# Handle both package imports and direct execution
try:
    from .sphere import GlobalProfile, SphereConstraint, StepResult, StepType
except ImportError:
    from sphere import GlobalProfile, SphereConstraint, StepResult, StepType


# =============================================================================
# ยง 1. Alert System
# =============================================================================

class AlertLevel(Enum):
    """Severity levels for alerts."""
    DEBUG = auto()
    INFO = auto()
    WARNING = auto()
    CRITICAL = auto()
    VIOLATION = auto()


@dataclass
class Alert:
    """An alert generated by the monitoring system."""
    level: AlertLevel
    message: str
    timestamp: datetime = field(default_factory=datetime.now)
    step_number: Optional[int] = None
    fuel_level: Optional[int] = None
    details: Optional[dict] = None
    
    def __str__(self) -> str:
        prefix = f"[{self.level.name}]"
        step_info = f" Step {self.step_number}:" if self.step_number is not None else ""
        fuel_info = f" (fuel={self.fuel_level})" if self.fuel_level is not None else ""
        return f"{prefix}{step_info} {self.message}{fuel_info}"
    
    def to_dict(self) -> dict:
        return {
            'level': self.level.name,
            'message': self.message,
            'timestamp': self.timestamp.isoformat(),
            'step': self.step_number,
            'fuel': self.fuel_level,
            'details': self.details,
        }


# =============================================================================
# ยง 2. Sphere Monitor
# =============================================================================

class SphereMonitor:
    """
    Real-time monitoring of sphere constraints.
    
    Responsibilities:
    - Generate alerts when thresholds are crossed
    - Track fuel consumption rate
    - Provide veto recommendations
    - Maintain audit log
    """
    
    def __init__(
        self,
        constraint: SphereConstraint,
        warning_threshold: float = 0.3,    # warn when fuel < 30% of R
        critical_threshold: float = 0.1,   # critical when fuel < 10% of R
        high_consumption_threshold: float = 0.1,  # alert if single step consumes > 10% of R
    ):
        self.constraint = constraint
        self.warning_threshold = warning_threshold
        self.critical_threshold = critical_threshold
        self.high_consumption_threshold = high_consumption_threshold
        
        # State
        self.alerts: List[Alert] = []
        self.step_count = 0
        self.fuel_history: List[int] = []
        self.strict_step_count = 0
    
    def reset(self):
        """Reset monitor state."""
        self.alerts = []
        self.step_count = 0
        self.fuel_history = []
        self.strict_step_count = 0
    
    def check(self, result: StepResult, profile: GlobalProfile) -> List[Alert]:
        """
        Check step result and generate appropriate alerts.
        
        Args:
            result: The step result to check
            profile: Current profile after step
        
        Returns:
            List of alerts generated
        """
        alerts = []
        self.step_count += 1
        self.fuel_history.append(profile.fuel)
        
        if result.is_strict:
            self.strict_step_count += 1
        
        # Check for violation
        if result.is_violation:
            alerts.append(Alert(
                level=AlertLevel.VIOLATION,
                message=f"WeakMono violated! Coords {result.increased_coords} increased",
                step_number=self.step_count,
                fuel_level=profile.fuel,
                details={'increased_coords': result.increased_coords},
            ))
        
        # Check fuel levels
        fuel_ratio = profile.fuel / self.constraint.R if self.constraint.R > 0 else 0
        
        if fuel_ratio < self.critical_threshold:
            alerts.append(Alert(
                level=AlertLevel.CRITICAL,
                message=f"CRITICAL: Fuel at {fuel_ratio*100:.1f}% ({profile.fuel}/{self.constraint.R})",
                step_number=self.step_count,
                fuel_level=profile.fuel,
            ))
        elif fuel_ratio < self.warning_threshold:
            alerts.append(Alert(
                level=AlertLevel.WARNING,
                message=f"Low fuel: {fuel_ratio*100:.1f}% ({profile.fuel}/{self.constraint.R})",
                step_number=self.step_count,
                fuel_level=profile.fuel,
            ))
        
        # Check high consumption
        if result.is_strict:
            consumption_ratio = result.fuel_consumed / self.constraint.R if self.constraint.R > 0 else 0
            if consumption_ratio > self.high_consumption_threshold:
                alerts.append(Alert(
                    level=AlertLevel.WARNING,
                    message=f"High consumption: -{result.fuel_consumed} in single step ({consumption_ratio*100:.1f}% of budget)",
                    step_number=self.step_count,
                    fuel_level=profile.fuel,
                    details={'consumed': result.fuel_consumed, 'decreased_coords': result.decreased_coords},
                ))
        
        # Check if approaching budget exhaustion
        if self.strict_step_count > 0 and len(self.fuel_history) > 0:
            total_consumed = self.fuel_history[0] - self.fuel_history[-1]
            avg_consumption = total_consumed / self.strict_step_count if self.strict_step_count > 0 else 0
            if avg_consumption > 0:
                estimated_remaining_steps = profile.fuel / avg_consumption
                if estimated_remaining_steps < 5 and profile.fuel > 0:
                    alerts.append(Alert(
                        level=AlertLevel.INFO,
                        message=f"Estimated ~{estimated_remaining_steps:.1f} strict steps remaining",
                        step_number=self.step_count,
                        fuel_level=profile.fuel,
                    ))
        
        self.alerts.extend(alerts)
        return alerts
    
    def should_veto(self, result: StepResult, profile_after: GlobalProfile) -> tuple[bool, Optional[str]]:
        """
        Determine if an action should be vetoed.
        
        Returns:
            (should_veto, reason)
        """
        # Always veto violations
        if result.is_violation:
            return True, f"WeakMono violated: coords {result.increased_coords} increased"
        
        # Veto if would leave sphere
        if not profile_after.in_sphere(self.constraint.R):
            return True, f"Would exit sphere: fuel={profile_after.fuel} > R={self.constraint.R}"
        
        # Optional: veto if would enter critical zone
        if profile_after.fuel < self.constraint.R * self.critical_threshold:
            return True, f"Would enter critical zone: fuel={profile_after.fuel}"
        
        return False, None
    
    def alert_count(self) -> dict:
        """Count alerts by level."""
        counts = {level.name: 0 for level in AlertLevel}
        for alert in self.alerts:
            counts[alert.level.name] += 1
        return counts
    
    def summary(self) -> dict:
        """Get monitoring summary."""
        return {
            'total_steps': self.step_count,
            'strict_steps': self.strict_step_count,
            'alerts': self.alert_count(),
            'final_fuel': self.fuel_history[-1] if self.fuel_history else None,
            'fuel_consumed': self.fuel_history[0] - self.fuel_history[-1] if len(self.fuel_history) > 1 else 0,
        }
    
    def export_alerts(self, filepath: str):
        """Export alerts to JSON file."""
        with open(filepath, 'w') as f:
            json.dump([a.to_dict() for a in self.alerts], f, indent=2)


# =============================================================================
# ยง 3. Audit Logger
# =============================================================================

class AuditLogger:
    """
    Detailed audit logging for sphere-guarded execution.
    
    Provides:
    - Complete execution trace
    - Fuel consumption breakdown by coordinate
    - Mode transitions
    - Alert history
    """
    
    def __init__(self, constraint: SphereConstraint):
        self.constraint = constraint
        self.entries: List[dict] = []
        self.coord_consumption: dict = {name: 0 for name in constraint.names}
    
    def log_step(
        self,
        step_number: int,
        profile_before: GlobalProfile,
        profile_after: GlobalProfile,
        result: StepResult,
        action: str,
        mode: Optional[str] = None,
    ):
        """Log a single step."""
        entry = {
            'step': step_number,
            'action': action,
            'mode': mode,
            'type': result.step_type.name,
            'fuel_before': result.fuel_before,
            'fuel_after': result.fuel_after,
            'consumed': result.fuel_consumed,
            'profile_before': list(profile_before.values),
            'profile_after': list(profile_after.values),
        }
        self.entries.append(entry)
        
        # Track per-coordinate consumption
        if result.is_strict:
            for i in result.decreased_coords:
                if i < len(self.constraint.names):
                    self.coord_consumption[self.constraint.names[i]] += int(result.delta[i])
    
    def get_trace(self) -> List[dict]:
        """Get complete execution trace."""
        return self.entries.copy()
    
    def get_consumption_by_coord(self) -> dict:
        """Get fuel consumption breakdown by coordinate."""
        return self.coord_consumption.copy()
    
    def export(self, filepath: str):
        """Export audit log to JSON."""
        data = {
            'constraint': {
                'R': self.constraint.R,
                'D': self.constraint.D,
                'names': self.constraint.names,
            },
            'consumption_by_coord': self.coord_consumption,
            'trace': self.entries,
        }
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=2)


# =============================================================================
# ยง 4. Composite Monitor
# =============================================================================

class CompositeMonitor:
    """
    Combines multiple monitoring strategies.
    """
    
    def __init__(self, monitors: List[SphereMonitor]):
        self.monitors = monitors
    
    def check(self, result: StepResult, profile: GlobalProfile) -> List[Alert]:
        """Check all monitors and aggregate alerts."""
        all_alerts = []
        for monitor in self.monitors:
            alerts = monitor.check(result, profile)
            all_alerts.extend(alerts)
        return all_alerts
    
    def should_veto(self, result: StepResult, profile_after: GlobalProfile) -> tuple[bool, Optional[str]]:
        """Veto if any monitor recommends veto."""
        for monitor in self.monitors:
            veto, reason = monitor.should_veto(result, profile_after)
            if veto:
                return True, reason
        return False, None
