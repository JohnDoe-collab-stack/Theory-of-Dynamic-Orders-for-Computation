import Mathlib.Data.Set.Basic
import Mathlib.Order.Basic


namespace LogicDissoc
namespace Boole
namespace AbstractKernel

/-!
# Abstract Kernel: Mathematical Foundations for Dynamic Orders

## Mathematical Structures

1. **Dynamic Projective System** (`DynamicKernel`): A discrete dynamical system
   `(State, step)` with a monotone approximation chain `approx : State → P`
   converging to `V(x) : P`.

2. **Temporal Monotonicity** (`mono_val`): Bits are persistent — `val s i = true`
   implies `val (step s) i = true`. This is the abstract form of halting monotonicity.

3. **Observational Equivalence** (`JEquivalent`): Defines when two states are
   indistinguishable relative to an observation set J.

4. **Boolean Closure** (`IsGeneratedBy`): The smallest Boolean algebra containing
   a generator family F.

## Relationship to LogicDissoc

| Abstract (here)     | Concrete (LogicDissoc)         |
|---------------------|--------------------------------|
| `DynamicKernel`     | Minsky machine (`step`, `run`) |
| `mono_val`          | `haltsWithinBool_mono`         |
| `JEquivalent`       | Component equality on `P_vec`  |
| `DependsOnlyOn`     | `DependsOnlyOnCut/Bit`         |
| `IsGeneratedBy`     | Boolean algebra on `F_struct`  |
-/

section BasicData

variable (Index : Type*)
variable (State : Type*)

variable (val : State → Index → Bool)

/-! ## 2. Index Layer (Geometric Profile) -/

variable (Profile : Type)
variable (profileOfIndex : Index → Profile)

/-! ## 3. Bit Layer: Atomic Predicates -/

/-- Set of states where the bit at index `i` is 1. -/
def BitAt (i : Index) : Set State :=
  { s : State | val s i = true }

/-- Set of states where the bit at index `i` is 0. -/
def BitIsZero (i : Index) : Set State :=
  { s : State | val s i = false }

open Set

@[simp] lemma mem_BitAt (i : Index) (s : State) :
  s ∈ BitAt Index State val i ↔ val s i = true :=
Iff.rfl

@[simp] lemma mem_BitIsZero (i : Index) (s : State) :
  s ∈ BitIsZero Index State val i ↔ val s i = false :=
Iff.rfl

lemma BitIsZero_eq_compl (i : Index) :
  BitIsZero Index State val i = (BitAt Index State val i)ᶜ := by
  ext s; simp [BitAt, BitIsZero]

end BasicData

/-! ## 4. Invariant Layer: Generated Boolean Algebra -/

section Invariants

variable {State : Type*}

/--
Inductive definition of the Boolean algebra generated by a family `F_state`.
-/
inductive IsGeneratedBy (F : Set (Set State)) : Set State → Prop
  | basic {S} (hS : S ∈ F) : IsGeneratedBy F S
  | empty : IsGeneratedBy F ∅
  | univ  : IsGeneratedBy F Set.univ
  | compl {S} (hS : IsGeneratedBy F S) : IsGeneratedBy F Sᶜ
  | union {S T} (hS : IsGeneratedBy F S) (hT : IsGeneratedBy F T) :
      IsGeneratedBy F (S ∪ T)
  | inter {S T} (hS : IsGeneratedBy F S) (hT : IsGeneratedBy F T) :
      IsGeneratedBy F (S ∩ T)

/--
The Boolean subalgebra of invariants on `State` generated by `F_state`.
-/
def GeneratedSubalgebra (F : Set (Set State)) :=
  { S : Set State // IsGeneratedBy F S }

end Invariants

/-! ## 5. Dependencies -/

section Dependencies

variable {Index State : Type*}
variable (val : State → Index → Bool)

/-- Two states are J-equivalent if they agree on all indices in J. -/
def JEquivalent (J : Set Index) (s₁ s₂ : State) : Prop :=
  ∀ i ∈ J, val s₁ i = val s₂ i

@[refl] lemma JEquivalent.refl (J : Set Index) (s : State) :
  JEquivalent val J s s := by
  intro i _hi; rfl

@[symm] lemma JEquivalent.symm {J : Set Index} {s₁ s₂ : State} :
  JEquivalent val J s₁ s₂ → JEquivalent val J s₂ s₁ := by
  intro h i hi
  symm; exact h i hi

@[trans] lemma JEquivalent.trans {J : Set Index} {s₁ s₂ s₃ : State} :
  JEquivalent val J s₁ s₂ → JEquivalent val J s₂ s₃ → JEquivalent val J s₁ s₃ := by
  intro h₁ h₂ i hi
  trans val s₂ i
  · apply h₁ i hi
  · apply h₂ i hi

/-- An invariant S depends only on J if J-equivalent states agree on membership in S. -/
def DependsOnlyOn (J : Set Index) (S : Set State) : Prop :=
  ∀ s₁ s₂, JEquivalent val J s₁ s₂ → (s₁ ∈ S ↔ s₂ ∈ S)

end Dependencies


/-! ## 5b. Projection-Based Observational Equivalence

For systems without boolean valuation (like `P_vec` in LogicDissoc),
we define equivalence via typed projections. This generalizes
`DependsOnlyOnCut` and `DependsOnlyOnBit` from LogicDissoc.
-/

section ProjectionDependencies

variable {State : Type*}

/-- Cylinder: all states sharing a common projection value.
    Generalizes `cutCylinder`, `bitCylinder` from LogicDissoc. -/
def Cylinder {Component : Type*} (proj : State → Component) (c : Component) : Set State :=
  { s | proj s = c }

/-- A set depends only on a single projection if agreeing on that
    projection implies agreeing on membership.
    Generalizes `DependsOnlyOnCut`, `DependsOnlyOnBit` from LogicDissoc. -/
def DependsOnlyOnProj {Component : Type*} (proj : State → Component) (S : Set State) : Prop :=
  ∀ s₁ s₂, proj s₁ = proj s₂ → (s₁ ∈ S ↔ s₂ ∈ S)

/-- Cylinders trivially depend only on their projection. -/
theorem Cylinder_dependsOnlyOnProj {Component : Type*} (proj : State → Component) (c : Component) :
    DependsOnlyOnProj proj (Cylinder proj c) := by
  intro s₁ s₂ h
  simp only [Cylinder, Set.mem_setOf_eq, h]

end ProjectionDependencies

/-! ## 6. Dynamic Kernel (Column 2) -/

section DynamicKernel

variable {Index : Type*} {P : Type*} [PartialOrder P]
variable {X : Type*} -- The object type
variable (V : X → P) -- The static obstruction map
variable (q : Index → P → Prop) -- The questions


/-- Upper bound of a set. -/
def IsUpperBound (s : Set P) (x : P) := ∀ a ∈ s, a ≤ x

/-- Least element of a set. -/
def IsLeast (s : Set P) (x : P) := x ∈ s ∧ ∀ a ∈ s, x ≤ a

/-- Least upper bound of a set. -/
def IsLUB (s : Set P) (x : P) := IsLeast { b | IsUpperBound s b } x

/--
**Dynamic Projective System**

A `DynamicKernel` is a discrete dynamical system with:
- **Monotone approximation**: `approx s ≤ approx (step s)` — chain ascends toward `V(x)`
- **Monotone bits**: `val s i = true → val (step s) i = true` — persistence
- **Soundness**: `val s i = true → q i (approx s)` — bits reflect questions

This abstracts the behavior of the Minsky machine in `LogicDissoc.lean`,
where `haltsWithinBool_mono` is the concrete instance of `mono_val`.
-/
structure DynamicKernel (State : Type*) where
  /-- Transition function: advances the state by one step. -/
  step : State → State
  /-- Initialization: creates an initial state from an object `x`. -/
  init : X → State
  /-- Approximation: extracts a partial profile from the current state. -/
  approx : State → P
  /-- Bit reading: extracts the boolean value of a question `i` from the state. -/
  val : State → Index → Bool

  -- Axioms (Properties)

  /-- (mono_approx) The approximation improves or stays the same over time. -/
  mono_approx : ∀ s : State, approx s ≤ approx (step s)

  /-- (init_approx) The initial approximation is a lower bound of the true profile. -/
  init_approx : ∀ x : X, approx (init x) ≤ V x

  /-- (sound_val) If a bit is true, the corresponding question is already true in the approximation. -/
  sound_val : ∀ s i, val s i = true → q i (approx s)

  /-- (mono_val) Once a bit becomes true, it stays true. -/
  mono_val : ∀ s i, val s i = true → val (step s) i = true

/--
**Convergence & Exactness Properties**

These properties link the dynamic limit to the static truth.
They are propositions, so they don't affect computability of the structure itself.
-/
class DynamicConvergence (DK : DynamicKernel V q State) (F : Set X) : Prop where
  /-- (conv_approx) The approximation converges to V(x) for x in the fragment F. -/
  conv_approx :
    ∀ x ∈ F, IsLUB { p | ∃ n, p = DK.approx (DK.step^[n] (DK.init x)) } (V x)

  /-- (exact_val) The bits eventually reflect exactly the static questions for V(x). -/
  exact_val :
    ∀ x ∈ F, ∀ i,
      (∃ T, ∀ t ≥ T, DK.val (DK.step^[t] (DK.init x)) i = true) ↔ q i (V x)

end DynamicKernel


/-! ## 7. Dynamic Boolean Logic (Column 3) -/

section DynamicLogic

variable (Index : Type*)

/--
**Positive Boolean Formulas**

Positive boolean formulas over atoms indexed by `Index`.
No negation is allowed here (monotonicity).
-/
inductive Form
  | atom : Index → Form
  | and  : Form → Form → Form
  | or   : Form → Form → Form
  deriving DecidableEq, Repr

variable {Index} {State : Type*}

/--
**Dynamic Evaluation**

Evaluates a formula on a state using the bit-reading function `val`.
-/
def evalState (val : State → Index → Bool) (φ : Form Index) (s : State) : Bool :=
  match φ with
  | .atom i   => val s i
  | .and φ ψ  => evalState val φ s && evalState val ψ s
  | .or  φ ψ  => evalState val φ s || evalState val ψ s

end DynamicLogic

end AbstractKernel
end Boole
end LogicDissoc
